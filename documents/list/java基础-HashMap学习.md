HashMap是基于哈希表的Map接口的实现。该实现提供了所有可选的map操作的所有的实现，并且允许null键和null值。HashMap与HashTable在大体上是相同的，除了HashMap是不同步的，并且允许null值和null键。这个类并不保证map中的数据的顺序，特别的，该类并不能保证，随着时间的推移，顺序将保持不变。也就是说，随着对该map的操作，map中的数据的顺序是有可能发生变化的。

该类的实现提供了基础操作get和put的固定时间性能，假设hash函数在桶中合理的分配元素。**对集合视图的迭代需要与HashMap实例的“容量”（bucket的数量）加上它的大小（键值映射的数量）成比例的时间。因此，如果迭代器的性能是非常重要的话，不要把初始化容量设置的太大是及其重要的。**

一个HashMap的实例有两个参数影响它的性能：**初始化容量和负载因子**。容量是在哈希表中的桶的数量，初始化容量仅仅就是在哈希表被创建的时候的容量。负载因子是一种度量在自动增加哈希表容量之前允许其获得的满量。当哈希表中的条目数超过加载因子和当前容量的乘积时，该哈希表将会被重新hash(rehashed)（也就是说，内部数据结构会被重建），因此，哈希表的数量大约是budget数量的两倍。

作为一个通用的规则，默认的负载因子(0.75)在时间和空间消耗方面提供了一个权衡。更高的值降低了空间消耗但是增加了搜索消耗（反映在HashMap的大多数操作中，包括get和put）。当设置他的初始化容量的时候，在map中的期望的元素数量和他的负载因子应该要被考虑在内，以减少重新hash操作的次数。如果初始化容量大于元素的最大数量除以负载因子，则重新hash操作将不会发生。

如果很多映射被保存到HashMap实例中，使用一个足够大小的容量初始化该HashMap将会允许映射保存的更有效率，相比于随着表的增长，当需要的时候自动运行重新hash操作来说。注意，使用很多相同hashcode()的键是降低任何哈希表性能的一个确定的方法。为了改善影响，当键是Comparable的，该类可能会在所有的键中使用比较顺序来帮助打破关系。

注意，该实现不是同步的。如果多个线程同时访问HasMap，并且至少有一个线程在结构上更改了映射，一定要在外部进行同步化设置。（一个结构化修改是操作包括添加，删除一个或多个映射，仅仅修改一个实例中已经包含的键的值不是结构化修改。）这通常是通过对自然封装映射的对象进行同步来实现的。

如果没有这样的对象存在，该map应该使用ollections#synchronizedMap Collections.synchronizedMap方法进行封装。这最好在创建的时候做这件事情，来阻止偶然的对该map的非同步访问：

```
    Map m = Collections.synchronizedMap(new HashMap());
```

注意，不能保证迭代器的快速失效行为，因为，通常来说，在存在不同步的并发修改的情况下，不可能做出任何硬性保证。失败快速迭代器以最大努力的方式抛出ConcurrentModificationException。因此，依赖这个异常编写一个程序用于纠正异常是错误的：迭代器的快速失效行为应该仅仅被用于检测bug。

这个map通常充当着一个装箱哈希表，但是当容器太大的时候，他们被转换为TreeNode的容器，每一个都相同的被结构化为java.util.TreeMap。大多数方法都尝试使用正常的装箱，但是在适当的情况下，被转化为TreeNode（仅仅通过检查node实例）。树节点的容器可以像其他容器一样被遍历和使用，但是当元素过多的时候，提供快速查询。然而，因为大多数正常使用的箱子不是负载过多，所以对于树容器的存在性的检查，在表方法的过程中可能会被延迟。树容器（也就是容器内所有的元素都是树节点）通过hashcode被排序，但是在绑定的情况下，如果两个元素是相同的“类C实现了Comparable接口”，那么他们的CompareTo方法将会被用于排序。（我们通过反射进行验证来保守的检查通用类型）。在键key有不同的哈希或是可排序的情况下，树容器的add方法的复杂性在提供最坏情况下的O(log n)操作是有价值的，因此，在偶然或恶意使用hashCode（）方法返回分布不均匀的值以及许多键共享一个hashCode的值的情况下，只要它们具有可比性，性能就会下降。如果两者都不适用，与不采取预防措施相比，我们可能在时间和空间上浪费大约两个因素。

因为TreeNode是大约常规节点的两倍大小，只有当容器包含足够的节点以保证使用时，我们才使用它们。并且当他们变得非常小的时候（由于移除或重新调整大小(resize)），他们会被转换回普通的容器。在使用分布良好的用户哈希代码时，树容器很少被使用。理想情况下，在随意哈希的情况下，容器中的节点的频率服从参数平均约为0.5，默认调整大小的阈值为0.75的泊松分布，尽管由于粒度的调整，差异很大。忽略差异，